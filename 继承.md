\#继承

\*定义: 自己没有的属性和方法,拿过别人有的来用,就叫继承

\*实现:利用原型中的成员可以被和其相关的对象共享着一属性

\#\#混入式继承

\*for in

\#\#原型继承

１．继承原型的成员

２．直接替换原型对象\(手动添加constructor属性\)

３．利用混入的方式给原型对象添加成员

注意：使用替换原型的方式实现继承，现有原型中的成员就会丢失

\#\#经典继承

\`\`\`

\`\`\`

Object.create\(obj\)

解决兼容性问题:

1.检测浏览器是否支持 Object.create 方法,如果支持,直接返回 Object.create\(obj\) .如果不支持,手动添加给

2.自定义函数,在函数内部判断是否 支持 Object.create 方法,如果不支持,手动添加

\#原型链

\*每个构造函数都有原型对象, 每个对象都会有构造函数, 每个原型对象都是对象,都会有构造函数.....这样就会形成一个原型链

\#\#\#原型继承:通过修改原型的结构,实现继承的方式就是原型继承

\#Object.prototype的成员

\#\#1.constructor

\*原型中的一个属性,指向与其相关的构造函数

\#\#2.hasOwnProperty

\*一个方法,用来判断对象本身\(不包含原型\)是否拥有某个属性

\#\#3.propertyIsEnumerable

\*判断属性是否属于对象本身,判断属性是否可以被遍历

\#\#4.toString和toLocaleString

通用格式字符串;本地设置的格式的字符串

\#\#5.valueOf

\*获取当前对象的值

\*在对象参与运算时,默认先去调用对象的ValueOf方法,若无法进行运算,再去调用p的toString方法运算

\#\#6.\_\_proto\_\_

\*原型对象中的属性,可以通过 对象. \_\_proto\_\_  访问原型对象

\#\#7.isPrototypeOf

\*对象1. isPrototypeOf \(对象2\);    判断对象1是否是对象2的原型

\#Function创建函数

\#\#创建函数方式

\*1.直接声明函数

\*2.函数表达式

\*3.new Function

无参:创建的是空函数;     函数体: 创建的是无参的函数

多个参数: 前边的都是形参,最后一个是函数体

Function接收的所有参数都是字符串形式!!!

\#\#\#解决代码过长:

\* 1.字符串拼接 换行; 2.使用模板;  3.使用反引号实现换行

\#arguments对象

\*,函数内部的一个对象,当函数调用时,系统会将所有传入的实参,依次存入这个数组对象中

注意: 不管有没有形参,实参都会被传入该对象

```
     arguments .length:表示传入实参的个数;

      arguments .callee: 指向函数本身
```

\#eval

\*是函数,可以将字符串转换成JavaScript代码并运行

注意: 解析JSON格式字符串,将{}解析为代码段

解决方法: 1. JSON格式的字符串 前面拼接 "var 变量名="

```
           2.eval\("\("+JSON格式的字符串+"\)"\);
```

\#\#静态成员:构造函数的属性和方法    \(Person.成员\)

\#\# 实例成员:实例的属性和方法\(通过实例对象访问的属性和方法\)   \(p.成员\)

\#Function和eval的区别

\*共同点:都是将字符串转换成ｊｓ代码．

不同点：Function创建的是函数,不会直接调用,只有手动调用的时候才会执行

```
         eval把字符串转换成js代码后直接就执行了
```

