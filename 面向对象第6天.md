---

\#线程

\*单线程: 一次只可以处理一件事情

\*多个线程可以同时处理多件事情

\*js是单线程的

\*js中分了三个任务:

```
1.渲染任务

2.js的代码执行任务

3.事件处理任务\(setTimeOut和setInterval\)
```

\*js中的执行顺序: 先执行主要任务,后执行次要任务\(回调函数\/setTimeout...\)

\#闭包:就是一个函数

\#缓存

\*cache

\#\#作用

\*将一些常用的数据存储起来,提供使用,提高性能

\#\#\#缓存: 硬件缓存\/浏览器缓存\/内存型数据库\/CDN  Content Delivery Network

\#delete关键字

\*删除var 开头的变量; 删除对象中的键值对;

\#沙箱

\*与外界隔绝的一个环境,外界无法修改环境内任何信息,沙箱内的东西属于一个世界

\#\#360沙箱模式

\*将软件和操作系统隔离,以达到安全的目的. 隔离app的空间,每个app独立运行.

\*苹果手机的app使用的就是沙箱模式,

\#\#js中的沙箱模式

\*立即执行函数表达式\(IIFE\)

\(如果需要,向windown对象添加成员,以暴力借口\)

\*不会暴露任何的全局变量,可以形成一个封闭的空间

\#\#\#沙箱模式一般书写在第三方框架,插件,独立的组件

\#\#优势

1.使用IIFE,不会暴露全局变量,造成全局变量污染

2.数据与外界隔离,外界不可修改

\#\#实现原理

\*函数可以构建作用域,上级作用域不能直接访问下级作用域

\#函数调用的四种模式

\#\#函数模式  test\(\)

\*this: 指向windown全局对象

\#\#方法模式  obj.test\(\)

\*this: 指向调用这个方法的对象

\#\#构造函数模式  var obj = new Person\(\);

\*this: 指向new创建出来的对象

\#\#上下文模式

\*this--&gt;指定的是谁就是谁

\*js中的上下文: context:执行环境的意思\(this\)

\*在上下文调用模式中,修改this,可以修改函数的调用方法

\#\#\#apply

\*函数.apply\(对象,\[函数需要的参数列表,是一个数组\]\)

\*eg: sayHello.apply\(obj,\[1,2,3\]\);

\*使用数组进行传参,但是在函数调用的时候,会把数组一一拆解成单个的形参.

\#\#\#call

\*函数.call\(对象,\[arg1\], \[arg2\],  \[arg3\]...\)

\*eg: sayHello.apply\(obj,1,2,3\);

\#\#\#区别

\*第一个参数都是把this修改为当前对象的

\*apply用于函数形参不确定的情况下;call用于形参确定的情况下.

\*apply和call方法第一个传递null的时候,都表示为函数调用模式,也就是将this指向windown.

